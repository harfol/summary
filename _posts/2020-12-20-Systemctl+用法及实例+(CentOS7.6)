---
layout: post
title: Systemctl 用法及实例(CentOS7.6)
date: 2020-12-20 12:20:23 +0900
category: CentOS7.6
---
## 前言
Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。

## 存放位置
#系统服务，开机不需要登录就能运行的程序（可以用于开机自启）
**/usr/lib/systemd/system** 
#用户服务，需要登录后才能运行程序
**/usr/lib/systemd/user**
#命名
**一般xxx.service**

## Quick Start
```shell
# 运行nginx后台服务
[Unit]
Description=nginx
After=network.target
[Service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid
ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
ExecStop=/usr/local/nginx/sbin/nginx -s stop -c /usr/local/nginx/conf/nginx.conf
ExecReload= /usr/local/nginx/sbin/nginx -s reload -c /usr/local/nginx/conf/nginx.conf
PrivateTmp=ture
[Install]
WantedBy=multi-user.target
```

```shell
# code-server 后台运行
[Unit]
Description=code-server background running.

[Service]
Type=simple
PIDFile=/run/code-server.pid
ExecStart=/usr/bin/code-server --config /etc/code-server/code-server.config.yaml
KillSignal=SIGQUIT
TimeoutStopSec=5

[Install]
WantedBy=multi-user.target
```

## 参数详解
**[Unit]**
```shell
Description：简短描述
Documentation：文档地址
Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败
Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败
BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行
Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动
After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动
Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行
Condition...：当前 Unit 运行必须满足的条件，否则不会运行
Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败

   +-------------------+    +---------------------+
   |After->Condition...| -> |Requires -> Assert...| -|
   +-------------------+    +---------------------+
   +-----+    +-------+    +------+
-> |Wants| -> |BindsTo| -> |Before|
   +-----+    +-------+    +------+
```

**[Service]**
```shell
Type：定义启动时的进程行为。它有以下几种值。
    Type=simple：(默认值)启动一个子进程运行命令，用于不会退出的程序
    Type=forking：fork一个字进程，等待命令完成后退出，多用于后台进程 
    Type=oneshot：systemctl 等待命令完成再往下执行，像在控制台执行一个命令一样
    Type=dbus：当前服务通过D-Bus启动
    Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行
    Type=idle：若有其他任务执行完毕，当前服务才会运行
ExecStart：启动当前服务的命令
ExecStartPre：启动当前服务之前执行的命令
ExecStartPost：启动当前服务之后执行的命令
ExecReload：重启当前服务时执行的命令
ExecStop：停止当前服务时执行的命令
ExecStopPost：停止当其服务之后执行的命令
RestartSec：自动重启当前服务间隔的秒数
Restart：定义何种情况 Systemd 会自动重启当前服务 
    no(默认值)： # 退出后无操作
    on-success:  # 只有正常退出时（退出状态码为0）,才会重启
    on-failure:  # 非正常退出时，重启，包括被信号终止和超时等
    on-abnormal: # 只有被信号终止或超时，才会重启
    on-abort:    # 只有在收到没有捕捉到的信号终止时，才会重启
    on-watchdog: # 超时退出时，才会重启
    always:      # 不管什么退出原因，都会重启（除了systemctl stop）
    # 对于守护进程，推荐用on-failure
KillMode的类型：
    control-group(默认)：# 当前控制组里的所有子进程，都会被杀掉
    process: # 只杀主进程
    mixed:   # 主进程将收到SIGTERM信号，子进程收到SIGKILL信号
    none:    # 没有进程会被杀掉，只是执行服务的stop命令
TimeoutSec：停止命令执行前等待秒数。
TimeoutStartSec：启动命令执行后等待秒数，超时停止。（0 关闭超时检测）
TimeoutStopSec：停止命令执行后等待秒数，超时使用 SIGKILL 停止服务。
Environment：为服务指定环境变量。
EnvironmentFile：环境变量文件，一行一个不要有空格。
Nice：进程优先级（默认为0）其中 -20 为最高优先级，19 为最低优先级。
WorkingDirectory：指定服务的工作目录，目录不纯在命令不能运行
RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件
User：指定运行服务的用户
Group：指定运行服务的用户组
MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private
    shared：服务与主机共用一个 Mount Namespace，相互影响
    slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上
    private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上
LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等，请看

-> +-----------+    +----+
   |User->Group| -> |Nice| -|
   +-----------+    +----+
-> +---------------------------------+    +---------------+
   |RootDirectory -> WorkingDirectory| -> |EnvironmentFile|
   +---------------------------------+    +---------------+
   +----+    +------------+    +
   |Type| -> |ExecStartPre -> ExecStart -> ExecStartPost| -> |
```

[Install]字段描述

WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中
    multi-user.target: # 表示多用户命令行状态，这个设置很重要
    graphical.target:  # 表示图形用户状体，它依赖于multi-user.target
RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中
Alias：当前 Unit 可用于启动的别名
Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit
脚本中分为三部分：[Unit]、[Service]、[Install]详细概述

## 参考
[# Systemd 服务管理教程](https://cloud.tencent.com/developer/article/1516125)
[# Linux systemd资源控制初探](https://www.cnblogs.com/jimbo17/p/9107052.html)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMTUwMjI3NzIsLTI0MjI3MjM2NCwxMj
M4NTcwNDQzLDE3OTg0NTA5NTQsMzI4MTM0MjEzLC0xMDgxMTMw
NDM5LC0xMjk0NjI5NDk5LC0xMjc3MDEzNjE4LDEyNjE3NTYxOD
ksMTIxOTI0Mzk2NV19
-->